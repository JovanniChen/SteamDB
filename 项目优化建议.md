# SteamDBé¡¹ç›®ä¼˜åŒ–å»ºè®®

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®æ˜¯ä¸€ä¸ªSteamå¹³å°APIå®¢æˆ·ç«¯ï¼Œå®ç°äº†ç”¨æˆ·ç™»å½•ã€ç§¯åˆ†ç®¡ç†ã€æ‰‹æœºä»¤ç‰Œè®¤è¯ç­‰åŠŸèƒ½ã€‚ç»è¿‡å…¨é¢åˆ†æï¼Œä»¥ä¸‹æ˜¯è¯¦ç»†çš„ä¼˜åŒ–å»ºè®®ã€‚

## ğŸ—ï¸ é¡¹ç›®ç»“æ„ä¼˜åŒ–

### 1. æ¨¡å—å‘½åè§„èŒƒåŒ–
**å½“å‰é—®é¢˜:**
- æ¨¡å—å `example.com/m/v2` æ— å®é™…æ„ä¹‰
- åŒ…åå¤§å°å†™ä¸ç»Ÿä¸€

**å»ºè®®ä¿®æ”¹:**
```go
// å½“å‰
module example.com/m/v2

// å»ºè®®æ”¹ä¸º
module github.com/yourname/steamdb
// æˆ–
module steamdb
```

### 2. ç›®å½•ç»“æ„è°ƒæ•´
**å½“å‰ç»“æ„:**
```
Steam/
â”œâ”€â”€ Config.go
â”œâ”€â”€ Dao/
â”œâ”€â”€ Errors/
â”œâ”€â”€ Model/
â”œâ”€â”€ Param/
â”œâ”€â”€ Protoc/
â””â”€â”€ Utils/
```

**å»ºè®®ç»“æ„:**
```
pkg/
â”œâ”€â”€ steam/
â”‚   â”œâ”€â”€ client.go      # HTTPå®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ auth.go        # è®¤è¯ç›¸å…³
â”‚   â”œâ”€â”€ points.go      # ç§¯åˆ†ç³»ç»Ÿ
â”‚   â””â”€â”€ config.go      # é…ç½®
â”œâ”€â”€ models/
â”œâ”€â”€ errors/
â”œâ”€â”€ utils/
â””â”€â”€ proto/
cmd/
â”œâ”€â”€ cli/
â””â”€â”€ server/
internal/
â””â”€â”€ config/
```

## ğŸ”’ å®‰å…¨æ€§æ”¹è¿›

### 1. æ•æ„Ÿä¿¡æ¯å¤„ç†
**é«˜é£é™©é—®é¢˜:**
```go
// main.go:25 - ç¡¬ç¼–ç å‡­æ®
err := d.Login("za0ww9ml4xl2", "HLHxGyRMm6Zi", "F54xOr9Tpyd5fAxgKx+RHR7vHik=")
```

**å»ºè®®è§£å†³æ–¹æ¡ˆ:**
```go
// 1. ä½¿ç”¨ç¯å¢ƒå˜é‡
username := os.Getenv("STEAM_USERNAME")
password := os.Getenv("STEAM_PASSWORD")
secret := os.Getenv("STEAM_GUARD_SECRET")

// 2. ä½¿ç”¨é…ç½®æ–‡ä»¶
type Config struct {
    Username string `yaml:"username"`
    Password string `yaml:"password"`
    Secret   string `yaml:"secret"`
}

// 3. äº¤äº’å¼è¾“å…¥
func getCredentials() (string, string, string) {
    reader := bufio.NewReader(os.Stdin)
    fmt.Print("ç”¨æˆ·å: ")
    username, _ := reader.ReadString('\n')
    fmt.Print("å¯†ç : ")
    password := getPassword() // ä½¿ç”¨éšè—è¾“å…¥
    fmt.Print("ä»¤ç‰Œ: ")
    secret, _ := reader.ReadString('\n')
    return strings.TrimSpace(username), strings.TrimSpace(password), strings.TrimSpace(secret)
}
```

### 2. TLSå®‰å…¨é…ç½®
**å½“å‰é—®é¢˜:**
```go
// dao.go:218 - è·³è¿‡è¯ä¹¦éªŒè¯
TLSClientConfig: &tls.Config{
    InsecureSkipVerify: true, // ç”Ÿäº§ç¯å¢ƒé«˜é£é™©
}
```

**å»ºè®®ä¿®æ”¹:**
```go
TLSClientConfig: &tls.Config{
    MinVersion: tls.VersionTLS12,
    // ç”Ÿäº§ç¯å¢ƒç§»é™¤InsecureSkipVerify
    // å¼€å‘ç¯å¢ƒå¯é…ç½®å¼€å…³
    InsecureSkipVerify: isDevelopment(),
}

func isDevelopment() bool {
    return os.Getenv("ENV") == "development"
}
```

## ğŸ“ é…ç½®ç®¡ç†ä¼˜åŒ–

### 1. åˆ›å»ºé…ç½®æ–‡ä»¶æ”¯æŒ
**æ–°å¢æ–‡ä»¶:** `pkg/config/config.go`
```go
package config

import (
    "gopkg.in/yaml.v3"
    "io/ioutil"
)

type Config struct {
    Steam struct {
        Username    string `yaml:"username"`
        Proxy       string `yaml:"proxy"`
        Timeout     int    `yaml:"timeout"`
        MaxRetries  int    `yaml:"max_retries"`
        Development bool   `yaml:"development"`
    } `yaml:"steam"`
    
    Logging struct {
        Level  string `yaml:"level"`
        Format string `yaml:"format"`
        File   string `yaml:"file"`
    } `yaml:"logging"`
}

func LoadConfig(path string) (*Config, error) {
    data, err := ioutil.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    var config Config
    err = yaml.Unmarshal(data, &config)
    return &config, err
}
```

**é…ç½®æ–‡ä»¶:** `config.yaml`
```yaml
steam:
  proxy: ""
  timeout: 10
  max_retries: 3
  development: false

logging:
  level: "info"
  format: "json"
  file: "steam.log"
```

### 2. ç¯å¢ƒå˜é‡æ”¯æŒ
```go
package config

import (
    "os"
    "strconv"
)

func (c *Config) LoadFromEnv() {
    if username := os.Getenv("STEAM_USERNAME"); username != "" {
        c.Steam.Username = username
    }
    if proxy := os.Getenv("STEAM_PROXY"); proxy != "" {
        c.Steam.Proxy = proxy
    }
    if timeout := os.Getenv("STEAM_TIMEOUT"); timeout != "" {
        if t, err := strconv.Atoi(timeout); err == nil {
            c.Steam.Timeout = t
        }
    }
}
```

## ğŸ“ æ—¥å¿—ç³»ç»Ÿæ”¹è¿›

### 1. ç»“æ„åŒ–æ—¥å¿—
**å»ºè®®ä½¿ç”¨logrusæˆ–zap:**
```go
package logger

import (
    "github.com/sirupsen/logrus"
    "os"
)

var Log *logrus.Logger

func Init(level string, format string, file string) {
    Log = logrus.New()
    
    // è®¾ç½®æ—¥å¿—çº§åˆ«
    if lvl, err := logrus.ParseLevel(level); err == nil {
        Log.SetLevel(lvl)
    }
    
    // è®¾ç½®è¾“å‡ºæ ¼å¼
    if format == "json" {
        Log.SetFormatter(&logrus.JSONFormatter{})
    } else {
        Log.SetFormatter(&logrus.TextFormatter{
            FullTimestamp: true,
        })
    }
    
    // è®¾ç½®è¾“å‡ºæ–‡ä»¶
    if file != "" {
        if f, err := os.OpenFile(file, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666); err == nil {
            Log.SetOutput(f)
        }
    }
}
```

### 2. æ›¿æ¢è°ƒè¯•è¾“å‡º
**å½“å‰é—®é¢˜:**
```go
// point.go:81 - ä½¿ç”¨fmt.Printfè°ƒè¯•
fmt.Printf("%v\n", reactionsReceive)
```

**å»ºè®®ä¿®æ”¹:**
```go
// ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
logger.Log.WithFields(logrus.Fields{
    "targetId":   targetId,
    "targetType": targetType,
}).Debug("è·å–ååº”æ•°æ®", "data", reactionsReceive)
```

## ğŸ”§ é”™è¯¯å¤„ç†ä¼˜åŒ–

### 1. è‡ªå®šä¹‰é”™è¯¯ç±»å‹
**æ–°å¢æ–‡ä»¶:** `pkg/errors/errors.go`
```go
package errors

import (
    "fmt"
    "net/http"
)

type SteamError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Detail  string `json:"detail,omitempty"`
}

func (e *SteamError) Error() string {
    return fmt.Sprintf("Steam APIé”™è¯¯ [%d]: %s", e.Code, e.Message)
}

// é¢„å®šä¹‰é”™è¯¯
var (
    ErrUnauthorized    = &SteamError{Code: 401, Message: "æœªæˆæƒè®¿é—®"}
    ErrRateLimited     = &SteamError{Code: 429, Message: "è¯·æ±‚é¢‘ç‡è¿‡é«˜"}
    ErrInvalidResponse = &SteamError{Code: 500, Message: "æ— æ•ˆå“åº”"}
    ErrNetworkTimeout  = &SteamError{Code: 408, Message: "ç½‘ç»œè¶…æ—¶"}
)

func NewHTTPError(statusCode int) *SteamError {
    switch statusCode {
    case http.StatusUnauthorized:
        return ErrUnauthorized
    case http.StatusTooManyRequests:
        return ErrRateLimited
    default:
        return &SteamError{
            Code:    statusCode,
            Message: fmt.Sprintf("HTTPé”™è¯¯: %d", statusCode),
        }
    }
}
```

### 2. é”™è¯¯åŒ…è£…å’Œé“¾å¼å¤„ç†
```go
import "github.com/pkg/errors"

func (d *Dao) Login(username, password, secret string) error {
    // è·å–RSAå…¬é’¥
    key, err := d.getRSA(username)
    if err != nil {
        return errors.Wrap(err, "è·å–RSAå…¬é’¥å¤±è´¥")
    }
    
    // åŠ å¯†å¯†ç 
    encPwd, err := d.encryptPassword(password, key)
    if err != nil {
        return errors.Wrap(err, "å¯†ç åŠ å¯†å¤±è´¥")
    }
    
    // å¼€å§‹è®¤è¯
    if err := d.beginAuthSessionViaCredentials(secret); err != nil {
        return errors.Wrap(err, "è®¤è¯ä¼šè¯å¯åŠ¨å¤±è´¥")
    }
    
    return nil
}
```

## ğŸ§ª æµ‹è¯•æ¡†æ¶æ·»åŠ 

### 1. å•å…ƒæµ‹è¯•
**æ–°å¢æ–‡ä»¶:** `pkg/steam/client_test.go`
```go
package steam

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

func TestNew(t *testing.T) {
    tests := []struct {
        name  string
        proxy string
        want  bool
    }{
        {"æ— ä»£ç†", "", true},
        {"æœ‰ä»£ç†", "127.0.0.1:8080", true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            dao := New(tt.proxy)
            assert.NotNil(t, dao)
            assert.NotNil(t, dao.httpCli)
            assert.NotNil(t, dao.credentials)
        })
    }
}

// Mockæµ‹è¯•
type MockSteamAPI struct {
    mock.Mock
}

func (m *MockSteamAPI) GetRSA(username string) (*SteamPublicKey, error) {
    args := m.Called(username)
    return args.Get(0).(*SteamPublicKey), args.Error(1)
}

func TestLoginWithMock(t *testing.T) {
    mockAPI := new(MockSteamAPI)
    mockAPI.On("GetRSA", "testuser").Return(&SteamPublicKey{
        Success: true,
        PublicKeyMod: "abc123",
        PublicKeyExp: "010001",
    }, nil)
    
    // æµ‹è¯•é€»è¾‘...
}
```

### 2. é›†æˆæµ‹è¯•
**æ–°å¢æ–‡ä»¶:** `test/integration_test.go`
```go
//go:build integration
// +build integration

package test

import (
    "testing"
    "os"
    "github.com/yourname/steamdb/pkg/steam"
)

func TestSteamLogin(t *testing.T) {
    if testing.Short() {
        t.Skip("è·³è¿‡é›†æˆæµ‹è¯•")
    }
    
    username := os.Getenv("TEST_STEAM_USERNAME")
    password := os.Getenv("TEST_STEAM_PASSWORD")
    secret := os.Getenv("TEST_STEAM_SECRET")
    
    if username == "" || password == "" || secret == "" {
        t.Skip("ç¼ºå°‘æµ‹è¯•å‡­æ®")
    }
    
    dao := steam.New("")
    err := dao.Login(username, password, secret)
    if err != nil {
        t.Fatalf("ç™»å½•å¤±è´¥: %v", err)
    }
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. è¿æ¥æ± ä¼˜åŒ–
```go
// ä¼˜åŒ–HTTPä¼ è¾“é…ç½®
Transport: &http.Transport{
    Proxy:                 proxyFn,
    DialContext:          (&net.Dialer{
        Timeout:   5 * time.Second,
        KeepAlive: 30 * time.Second,
    }).DialContext,
    TLSHandshakeTimeout:   10 * time.Second,
    ResponseHeaderTimeout: 10 * time.Second,
    ExpectContinueTimeout: 1 * time.Second,
    MaxIdleConns:          100,
    MaxIdleConnsPerHost:   20,
    MaxConnsPerHost:       50,
    IdleConnTimeout:       90 * time.Second,
}
```

### 2. ç¼“å­˜æœºåˆ¶
```go
package cache

import (
    "sync"
    "time"
)

type Cache struct {
    data map[string]cacheItem
    mu   sync.RWMutex
}

type cacheItem struct {
    value  interface{}
    expiry time.Time
}

func NewCache() *Cache {
    return &Cache{
        data: make(map[string]cacheItem),
    }
}

func (c *Cache) Set(key string, value interface{}, ttl time.Duration) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.data[key] = cacheItem{
        value:  value,
        expiry: time.Now().Add(ttl),
    }
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    item, exists := c.data[key]
    if !exists || time.Now().After(item.expiry) {
        return nil, false
    }
    return item.value, true
}
```

## ğŸ› ï¸ ä»£ç è´¨é‡æ”¹è¿›

### 1. æ¥å£æŠ½è±¡
```go
// å®šä¹‰æ¥å£
type SteamClient interface {
    Login(username, password, secret string) error
    GetUserInfo() (*UserInfo, error)
    AddReaction(targetId uint64, targetType int32, reactionId uint32) error
    GetSteamTime() (int64, error)
}

type HTTPClient interface {
    Do(req *http.Request) (*http.Response, error)
}

// å®ç°ä¾èµ–æ³¨å…¥
type Dao struct {
    httpClient  HTTPClient
    config      *config.Config
    logger      *logrus.Logger
    cache       *cache.Cache
    credentials *Credentials
}

func NewDao(httpClient HTTPClient, cfg *config.Config, logger *logrus.Logger) *Dao {
    return &Dao{
        httpClient:  httpClient,
        config:      cfg,
        logger:      logger,
        cache:       cache.NewCache(),
        credentials: &Credentials{},
    }
}
```

### 2. å¸¸é‡å®šä¹‰
```go
const (
    // HTTPç›¸å…³
    DefaultTimeout     = 10 * time.Second
    DefaultRetries     = 3
    DefaultUserAgent   = "SteamDB-Client/1.0"
    
    // Steamç›¸å…³
    SteamTimeWindow    = 30 * time.Second
    AuthCodeLength     = 5
    MaxIdleConns       = 100
    
    // ç›®æ ‡ç±»å‹
    TargetTypeProfile  = 1
    TargetTypeUGC      = 2
    
    // ååº”ç±»å‹
    ReactionTypeLike   = 1
    ReactionTypeAward  = 23
)
```

### 3. å‡½æ•°æ‹†åˆ†
```go
// å°†å¤§å‡½æ•°æ‹†åˆ†ä¸ºå°å‡½æ•°
func (d *Dao) Login(username, password, secret string) error {
    // 1. éªŒè¯è¾“å…¥å‚æ•°
    if err := d.validateLoginParams(username, password, secret); err != nil {
        return err
    }
    
    // 2. è·å–RSAå…¬é’¥
    key, err := d.getRSAPublicKey(username)
    if err != nil {
        return errors.Wrap(err, "è·å–RSAå…¬é’¥å¤±è´¥")
    }
    
    // 3. åŠ å¯†å¯†ç 
    encryptedPwd, err := d.encryptPassword(password, key)
    if err != nil {
        return errors.Wrap(err, "å¯†ç åŠ å¯†å¤±è´¥")
    }
    
    // 4. ä¿å­˜å‡­æ®
    d.saveCredentials(username, encryptedPwd, key.Timestamp)
    
    // 5. å¼€å§‹è®¤è¯
    return d.beginAuthentication(secret)
}

func (d *Dao) validateLoginParams(username, password, secret string) error {
    if username == "" {
        return errors.New("ç”¨æˆ·åä¸èƒ½ä¸ºç©º")
    }
    if password == "" {
        return errors.New("å¯†ç ä¸èƒ½ä¸ºç©º")
    }
    if secret == "" {
        return errors.New("Steam Guardå¯†é’¥ä¸èƒ½ä¸ºç©º")
    }
    return nil
}
```

## ğŸ“š æ–‡æ¡£å®Œå–„

### 1. README.md
```markdown
# SteamDB - Steamå¹³å°APIå®¢æˆ·ç«¯

## åŠŸèƒ½ç‰¹æ€§
- âœ… Steamç”¨æˆ·ç™»å½•è®¤è¯
- âœ… Steam Guardç§»åŠ¨è®¤è¯å™¨æ”¯æŒ
- âœ… ç§¯åˆ†ç³»ç»Ÿç®¡ç†
- âœ… ç”¨æˆ·ä¿¡æ¯è·å–
- âœ… å¸‚åœºç¡®è®¤æ“ä½œ

## å¿«é€Ÿå¼€å§‹

### å®‰è£…
```bash
go get github.com/yourname/steamdb
```

### åŸºæœ¬ä½¿ç”¨
```go
package main

import (
    "github.com/yourname/steamdb/pkg/steam"
    "log"
)

func main() {
    client := steam.New("")
    
    err := client.Login("username", "password", "shared_secret")
    if err != nil {
        log.Fatal("ç™»å½•å¤±è´¥:", err)
    }
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    info, err := client.GetUserInfo()
    if err != nil {
        log.Fatal("è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥:", err)
    }
    
    log.Printf("ç”¨æˆ·: %s, ä½™é¢: %d", info.PersonName, info.Balance)
}
```

### é…ç½®æ–‡ä»¶
åˆ›å»º `config.yaml`:
```yaml
steam:
  proxy: ""
  timeout: 10
  max_retries: 3

logging:
  level: "info"
  format: "json"
```
```

### 2. APIæ–‡æ¡£
**æ–°å¢æ–‡ä»¶:** `docs/api.md`
```markdown
# APIå‚è€ƒæ–‡æ¡£

## SteamClientæ¥å£

### Login
ç™»å½•Steamè´¦æˆ·

```go
func (c *Client) Login(username, password, secret string) error
```

**å‚æ•°:**
- `username`: Steamç”¨æˆ·å
- `password`: Steamå¯†ç 
- `secret`: Steam Guardå…±äº«å¯†é’¥

**è¿”å›å€¼:**
- `error`: ç™»å½•å¤±è´¥æ—¶çš„é”™è¯¯ä¿¡æ¯

**ç¤ºä¾‹:**
```go
err := client.Login("myusername", "mypassword", "ABCDEFGHIJ1234567890")
if err != nil {
    log.Fatal("ç™»å½•å¤±è´¥:", err)
}
```
```

## ğŸš€ éƒ¨ç½²å’Œæ„å»ºä¼˜åŒ–

### 1. Makefile
```makefile
.PHONY: build test lint clean docker

# å˜é‡å®šä¹‰
BINARY_NAME=steamdb
VERSION=$(shell git describe --tags --always --dirty)
LDFLAGS=-ldflags "-X main.Version=$(VERSION)"

# æ„å»º
build:
	go build $(LDFLAGS) -o bin/$(BINARY_NAME) cmd/cli/main.go

# æµ‹è¯•
test:
	go test -v ./...

test-integration:
	go test -v -tags=integration ./test/...

# ä»£ç æ£€æŸ¥
lint:
	golangci-lint run

# æ¸…ç†
clean:
	rm -rf bin/
	go clean

# Dockeræ„å»º
docker:
	docker build -t steamdb:$(VERSION) .

# å®‰è£…ä¾èµ–
deps:
	go mod download
	go mod tidy

# ç”Ÿæˆprotobuf
proto:
	protoc --go_out=. --go_opt=paths=source_relative \
		--go-grpc_out=. --go-grpc_opt=paths=source_relative \
		proto/*.proto
```

### 2. Dockerfile
```dockerfile
# æ„å»ºé˜¶æ®µ
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o steamdb cmd/cli/main.go

# è¿è¡Œé˜¶æ®µ
FROM alpine:latest

RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/steamdb .
COPY --from=builder /app/config.yaml .

CMD ["./steamdb"]
```

### 3. GitHub Actions CI/CD
**æ–°å¢æ–‡ä»¶:** `.github/workflows/ci.yml`
```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: [1.20, 1.21]

    steps:
    - uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: ${{ matrix.go-version }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

    - name: Install dependencies
      run: go mod download

    - name: Run tests
      run: go test -v -race -coverprofile=coverage.out ./...

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out

    - name: Run linter
      uses: golangci/golangci-lint-action@v3

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.21

    - name: Build
      run: make build

    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: steamdb-binary
        path: bin/steamdb
```

## ğŸ“‹ å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€ä¼˜åŒ– (1-2å‘¨)
1. âœ… ç§»é™¤ç¡¬ç¼–ç å‡­æ®
2. âœ… ä¿®å¤TLSå®‰å…¨é…ç½®
3. âœ… æ·»åŠ é…ç½®æ–‡ä»¶æ”¯æŒ
4. âœ… è§„èŒƒåŒ–é¡¹ç›®ç»“æ„

### ç¬¬äºŒé˜¶æ®µï¼šåŠŸèƒ½å¢å¼º (2-3å‘¨)
1. âœ… å®ç°ç»“æ„åŒ–æ—¥å¿—
2. âœ… æ·»åŠ é”™è¯¯å¤„ç†æ”¹è¿›
3. âœ… å®ç°æ¥å£æŠ½è±¡
4. âœ… æ·»åŠ ç¼“å­˜æœºåˆ¶

### ç¬¬ä¸‰é˜¶æ®µï¼šè´¨é‡ä¿è¯ (2-3å‘¨)
1. âœ… ç¼–å†™å•å…ƒæµ‹è¯•
2. âœ… æ·»åŠ é›†æˆæµ‹è¯•
3. âœ… å®Œå–„æ–‡æ¡£
4. âœ… è®¾ç½®CI/CDæµç¨‹

### ç¬¬å››é˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ– (1-2å‘¨)
1. âœ… ä¼˜åŒ–HTTPè¿æ¥æ± 
2. âœ… å®ç°è¯·æ±‚é‡è¯•ç­–ç•¥
3. âœ… æ·»åŠ æ€§èƒ½ç›‘æ§
4. âœ… ä¼˜åŒ–å†…å­˜ä½¿ç”¨

## ğŸ¯ æ€»ç»“

å½“å‰é¡¹ç›®åœ¨åŠŸèƒ½å®ç°ä¸Šæ¯”è¾ƒå®Œæ•´ï¼Œä½†åœ¨å·¥ç¨‹åŒ–æ–¹é¢è¿˜æœ‰è¾ƒå¤§æ”¹è¿›ç©ºé—´ã€‚é€šè¿‡ä»¥ä¸Šä¼˜åŒ–å»ºè®®ï¼Œå¯ä»¥æ˜¾è‘—æå‡é¡¹ç›®çš„ï¼š

- **å®‰å…¨æ€§**: ç§»é™¤ç¡¬ç¼–ç å‡­æ®ï¼ŒåŠ å¼ºTLSé…ç½®
- **å¯ç»´æŠ¤æ€§**: è§„èŒƒåŒ–ä»£ç ç»“æ„ï¼Œæ·»åŠ å®Œæ•´æµ‹è¯•
- **å¯æ‰©å±•æ€§**: å¼•å…¥æ¥å£æŠ½è±¡ï¼Œå®ç°ä¾èµ–æ³¨å…¥
- **å¯æ“ä½œæ€§**: å®Œå–„é…ç½®ç®¡ç†ï¼Œæ·»åŠ æ—¥å¿—ç³»ç»Ÿ
- **ç¨³å®šæ€§**: æ”¹è¿›é”™è¯¯å¤„ç†ï¼Œæ·»åŠ é‡è¯•æœºåˆ¶

å»ºè®®æŒ‰ç…§å®æ–½è®¡åˆ’é€æ­¥æ¨è¿›ï¼Œä¼˜å…ˆå¤„ç†å®‰å…¨æ€§é—®é¢˜ï¼Œç„¶åé€æ­¥å®Œå–„å…¶ä»–æ–¹é¢ã€‚